## kafka
```
1.什么是Kafka
2.什么是消息中间件
3.消息中间件的应用场景
4.Kafka优势和劣势
5.Kafka应用场景
6.kafka名词解释
  代理(Broker)
  主题(Topic)
  分区(partition)
  生产者(Producer)
  消费群组(Consumer Group)
  消费者(Consumer)
7.代理(Broker)
8.主题(Topic)
9.分区(Partition)
10.生产者(Producer)
  10.1.生产者如何保证消息不丢失(可靠性)
  10.2.生产者原理
11.消费者(Consumer)
12.参考资料

```

## 1.什么是Kafka
```
Kafka是消息中间件的一种,它是一个分布式、可分区、可复制的高性能消息系统,它提供普通消息系统的功能队列、发布订阅
Kafka使用队列模型时,它将处理工作平均分配给消费组(Consumer Group)中的消费者成员
Kafka使用发布订阅模式时,它可以将消息广播给多个消费组,也允许消息被多个消费者订阅
```

## 2.什么是消息中间件
```
消息中间件是一种异步通信协议,也可以说试一种通信软件,它可以为分布式应用、系统或者实体提供跨平台、异步、松耦合、高可靠性并且安全的通信功能
```

## 3.消息中间件的应用场景

```
1. 应用程序解耦
    比如用户注册送红包发送注册短信,传统做法是先用户注册然后送红包最后发送注册短信,
    使用消息队列用户注册成功后发送1个消息立即返回, 同时发送用户注册和送注册红包
    传统如果用户注册送红包发送注册短信分别需要用时50ms,就需要150ms=(50ms 用户注册 + 50ms 送红包 + 50ms发送注册短信)
    消息中间件用户注册成功后发送1个消息立即返回,同时发送用户注册和送注册红包,就需要100ms=(50ms 用户注册 + 50ms(送红包 + 发送注册短信))
    如果不需要发送短信,停用短信消费者即可,需要时启用短信消费者就好
    如果不需要送红包,停用送红包消费者即可,需要的启用送红包消费者就好
    从而提高吞吐量和应用解耦
    
2. 异步处理
    发送短信、发送邮件、注册送红包等

3. 流量削峰
    主要用于高并发业务场景,缓解短时间内高流量压垮应用比如秒杀和活动等,将用户请求放入消息队列中,如果消息队列成功最大数量,
    直接抛弃用户请求或跳转到错误页面
```


## 4. Kafka优势和劣势
```sh
优势:
  1.可靠性: Kafka是分布式负载均衡、分区、副本复制实现故障转移来保存可靠性.Kafka分布式的,一个数据多个副本,少数集群宕机,不会丢失数据,也不会导致不可用
  2.可扩展性: 可以通过简单的增加服务器横向扩展,无需停机
  3.持久性: Kafka消息持久化(零拷贝zero-copy)到磁盘上,副本机制实现数据沉余,保证数据不会丢失
  4.高性能: Kafka对于发布订阅订阅都具有很高吞吐量
 	单机写入TPS约在百万条/秒,即使在非常廉价的商用机器上也能做到单机支持每秒100K条消息的传输
   	零拷贝技术(sendfile zero copy)
    分布式存储
    点对点消息传递: 分区(Partition)可以在多个节点上(例如: 1个节点1个主题3分区吞吐量是300MB, 分成3个节点分别存放个主题3分区即300MB*3=900MB的吞吐量)
    磁盘顺序读顺序写
    批量读批量写
    kafka不保存消息状态,消费者通过记录主题分区中的offset表示之前的消息都被消费,offset之后的都是未消费,offset可以任意移动
        
        
缺点:
  消息乱序: Kafka只能保证单个分区(Partition)内部的消息有序,如果单个主题(Topic)有多个分区,分区之间无法保证消息有序
  重复消息: Kafka保证每条消息至少送达一次,虽然几率很小,但一条消息可能被送达多次.
  复杂性: Kafka需要Zookeeper的支持,主题(Topic)一般需要人工创建,部署和维护比一般MQ成本更高

```

## 5. Kafka应用场景?
```
1. 日志收集处理
2. 消息系统
3. 网站行为日志跟踪
4. 流式处理: 对输入数据流进行转换、聚合或汇总然后输出到某个地方,当然也可以是另一个流
5. 事件溯源
```

## 6. kafka名词解释?
```
代理(Broker): 是一个独立的Kafka服务器, 一个集群由多个Broker组成
  Broker接收来自生产者的消息保存到指定主题(Topic)中的分区(Partition)上并设置消息偏移(Offset)然后保存在磁盘上.
  Broker为消费者提供读取服务,对读取分区的请求作出响应,返回已提交到硬盘中的消息.
  单个Broker可以轻松处理上千个分区和每秒百万级消息量
  单个Broker在低延迟下也能处理支持每秒100K(上千条消息)条消息的传输

主题(Topic): 消息的类别称为Topic
  一个Broker包含一个或者多个主题(Topic),Kafka根据topic对消息进行归类,
  发布到Kafka集群的每条消息都需要指定一个topic

分区(partition):消息存储的队列
  每个主题(Topic)包含一个或者多个分区(Partition),每个partition内部是有序的
                                   
生产者(Producer): 发送消息的客户端
  负责发送消息到指定的代理(Broker)下的主题(Topic)中的分区(Partition)

消费群组(Consumer Group): 消息消费队列称为消费组
  一个消费组(Consumer Group)可以包含一个或者多个消费者(Consumer)
  注意消费组订阅某个主题,如果该主题的中的每个分区只能有一个消费者
  比如消费者G订阅了主题T并且主题只有2个分区分别是A和B,所以主题T最多只能有2个消费者

消费者(Consumer): 读取消息的客户端
  消费者(Consumer)负责从Broker中拉取消息并处理,设置已处理的消息偏移量
```

## 7. 代理(Broker)
```

```

## 8. 主题(Topic)

## 9. 分区(Partition)

## 10. 生产者(Producer)

### 10.1.生产者如何保证消息不丢失(可靠性)
> 实际使用时,根据应用特性选择,绝大多数情况下都会中和可靠性和性能选择第三种模
```
生产者如何保证消息不丢失:
1.最多一次(At most once): 消息可能会丢失但绝不重传
  啥都不管,发送出去就当作成功,这种情况当然不能保证消息成功投递到broker
  
2.至少一次(At least once): 消息可以重传但绝不丢失
  Master-Slave模型,只有当Master和所有Slave都接收到消息时,才算投递成功,这种模型提供了最高的投递可靠性,但是损伤了性能
  
3.精准一次(Exactly once): 每一条消息只被传递一次,这正是人们想要的
  只要Master确认收到消息就算投递成功


生产者保证消息不丢失(可靠性)配置:
1.acks=0 如果设置为0,则 producer 不会等待服务器的反馈.该消息会被立刻添加到 socket buffer 中并认为已经发送完成.
  在这种情况下,服务器是否收到请求是没法保证的,并且参数retries也不会生效(因为客户端无法获得失败信息).每个记录返回的 offset 总是被设置为-1.
  
2.acks=1 如果设置为1,leader节点会将记录写入本地日志,并且在所有 follower 节点反馈之前就先确认成功.在这种情况下,如果 leader 节点在接收记录之后,
  并且在 follower 节点复制数据完成之前产生错误,则这条记录会丢失.
  
3.acks=all 如果设置为all,这就意味着 leader 节点会等待所有同步中的副本确认之后再确认这条记录是否发送完成.只要至少有一个同步副本存在,
  记录就不会丢失.这种方式是对请求传递的最有效保证.acks=-1与acks=all是等效的.
  
生产者消息幂等保证: 
  1.为什么要引入幂等
    生产者进行retry会产生重试时,会重复产生消息.有了幂等性之后,在进行retry重试时,只会生成一个消息.
    
  2.幂等性实现:
    为了实现Producer的幂等性,Kafka引入了Producer ID(即PID)和Sequence Number
    PID: 每个新的Producer在初始化的时候会被分配一个唯一的PID,这个PID对用户是不可见的.
    Sequence Numbler: 对于每个PID,该Producer发送数据的每个<Topic, Partition>都对应一个从0开始单调递增的Sequence Number.
    
    Broker端在缓存中保存了这seq number,对于接收的每条消息,如果其序号比Broker缓存中序号大于1则接受它,否则将其丢弃.这样就可以实现了消息重复提交了.
    但是,只能保证单个Producer对于同一个<Topic, Partition>的Exactly Once语义.不能保证同一个Producer一个topic不同的partion幂等
    
  3.在kafka 0.11.0.0之前,是无法保证Exactly once的.但从0.11.0.0开始 producer 引入了幂等性的概念,保证消息只会被传递一次
```

### 10.2.生产者原理
```
生产者选择主题分区:
  1.如果没有Key值则进行轮询发送.
  2.如果有Key值,对Key值进行Hash计算得到hashCode,然后对分区数量取余.
  保证了同一个Key值的会被路由到同一个分区,如果想队列的强顺序一致性,可以让所有的消息都设置为同一个Key.
  


1. 获取生产者配置 ProduceConfig
2. 创建生产者实例 KafkaProducer
3. 发送消息
  1. 获取主题所有分区
  2. 选择分区
  3. 把消息放到记录收集器主题分区双端队列中
  4. 设置发送消息方式
    1. 按照分区直接发送
    2. 按照分区目标节点分组发送
  5. 获取记录收集器中已准备好的消息批次
  6. 创建客户端请求 ClientRequest
  7. 发送客户端请求 ClientRequest
  8. 接收客户端请求响应 ClientResponse
  8. 调用生产者回调 Callback

```

## 11. 消费者(Consumer)原理
```

```

## 12.参考资料
- [阿里大牛实战归纳——Kafka架构原理](https://juejin.im/post/5b59c6055188257bcc16738c)
- []()
- []()
- []()
- []()